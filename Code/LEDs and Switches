********************************************************
* Title: LED Light Blinking
*
* Objective: CMPEN 472 Homework 2
*           
* Revision: V3.2 for CodeWarrior 5.2 Debugger Simulation
*
* Date: Jan. 29, 2025 
*       
* Programmer: Abdullah Bin Jabr
*
* Company: The Pennsylvania State University
*          Department of Computer Science and Engineering
*
* Algorithm: Simple Parallel I/O use and time delay-loop demo
*
* Register use: A: LED Light on/off state and Switch 1 on/off state
*               X.Y: Delay loop counters
*
* Memory use: RAM Locations from $3000 for data,
*             RAM Locations from $3100 for program
*
* Input: Parameters hard-coded in the program - PORTB
*             Switch 1 at PORTB bit 0
*             Switch 2 at PORTB bit 1
*             Switch 3 at PORTB bit 2
*             Switch 4 at PORTB bit 3
*
* Output:     LED 1 at PORTB bit 4
*             LED 2 at PORTB bit 5
*             LED 3 at PORTB bit 6
*             LED 4 at PORTB bit 7
*
* Observation: This is a program that blinks LEDs and blinking period can
*              be changed with the delay loop counter value.
*
* Note: All Homework programs MUST have comments similar
*       to this Homework 2 program. So, please use those
*       comment format for all your subsequent CMPEN472
*       Homework programs.
*
*       Adding more explanations and comments help you and
*       others to understand your program later.
*
* Comments: This program is developed and simulated using CodeWarrior
*           development software and targeted for Axiom
*           Manufacturing's CSM-12C128 board running at 24MHz.
********************************************************

********************************************************
* Parameter Declaration Section
********************************************************
         XDEF     pstart          ; export 'pstart' symbol
         ABSENTRY pstart          ; for assembly entry point

* Symbols and Macros
PORTA    EQU     $0000           ; i/o port A addresses
DDRA     EQU     $0002
PORTB    EQU     $0001           ; i/o port B addresses
DDRB     EQU     $0003

********************************************************
* Data Section: address used [ $3000 to $30FF ] RAM memory
********************************************************
         ORG     $3000           ; Reserved RAM memory starting address
                                 ; for Data for CMPEN 472 class
Counter1 DC.W    $0100           ; X register count number for time delay
                                 ; inner loop for msec
Counter2 DC.W    $00E0           ; Y register count number for time delay
                                 ; outer loop for sec (Value was changed to
                                 ; match 1 sec blinking on device)
                                 ; Remaining data memory space for stack,
                                 ; up to program memory start

********************************************************
* Program Section: address used [ $3100 to $3FFF ] RAM memory
********************************************************
         ORG     $3100           ; Program start address, in RAM
pstart   LDS     #$3100          ; initialize the stack pointer
;        LDAA    #%11110000      ; LED 1,2,3,4 at PORTB bit 4,5,6,7 for CSM-12C128 board
         LDAA    #%11111111      ; LED 1,2,3,4 at PORTB bit 4,5,6,7 for Simulation only
         STAA    DDRB            ; set PORTB bit 4,5,6,7 as output
         LDAA    #%00000000
         STAA    PORTB           ; Turn off LED 1,2,3,4 (all bits in PORTB, for simulation)

mainLoop BSET    PORTB,%10000000 ; Turn ON LED 4 at PORTB bit 7
         JSR     delay1sec       ; Wait for 1 second
         BCLR    PORTB,%10000000 ; Turn OFF LED 4 at PORTB bit 7
         
         BSET    PORTB,%00010000 ; Turn ON LED 1 at PORTB bit 4
         JSR     delay1sec       ; Wait for 1 second
         BCLR    PORTB,%00010000 ; Turn OFF LED 1 at PORTB bit 4
         
         LDAA    PORTB
         ANDA    #%00000001      ; read switch 1 at PORTB bit 0
         BNE     sw1pushed       ; check to see if it is pushed

sw1notpush BCLR  PORTB,%00010000 ; turn OFF LED 1 PORTB bit 4 
         BRA     mainLoop

sw1pushed 

;          BSET   PORTB,%00010000 ; turn ON LED 1 at PORTB bit 4
;         JSR     delay1sec      ; No need to use this set of instructions here, 
                                 ; because the main loop is ran every time whether
                                 ; the switch is pressed or not, incurring 
                                 ; that delay of 1 sec regardless along with the
                                 ; setting and clearing which is done at the end of the outer loop
                                 ; IT JUMPS TO mainLoop everytime. This was checked by
                                 ; delaying one second at the end of BCLR 10000000 line and then
                                 ; clearing it again in the main loop which meant it was wasting a
                                 ; second, and clearing twice.
                                 ; so now our main loop runs on the outside with LED 1 and 4, and
                                 ; then when the button is switched, the sequence adds LEDs 2 and
                                 ; 3 to it with every loop!
;         BCLR  PORTB,%00010000   ; Turn OFF LED 1 at PORTB bit 4

***
         
         BSET   PORTB,%00100000  ; Turn ON LED 2 at PORTB bit 5
         JSR     delay1sec       ; Wait for 1 second
         BCLR  PORTB,%00100000   ; Turn OFF LED 2 at PORTB bit 5
         
         BSET   PORTB,%01000000  ; Turn ON LED 3 at PORTB bit 6
         JSR     delay1sec       ; Wait for 1 second
         BCLR  PORTB,%01000000   ; Turn OFF LED 3 at PORTB bit 6
         
***         
         
         
;         BSET   PORTB,%10000000  ; Turn ON LED 4 at PORTB bit 7
;         JSR     delay1sec      ; No need to use this set of instructions here, 
                                 ; because the main loop is ran every time whether
                                 ; the switch is pressed or not, incurring 
                                 ; that delay of 1 sec regardless along with the
                                 ; setting and clearing which is done at the end of the outer loop
                                 ; IT JUMPS TO mainLoop everytime. This was checked by
                                 ; delaying one second at the end of BCLR 10000000 line and then 
                                 ; clearing it again in the main loop which meant it was wasting a 
                                 ; second, and clearing twice.
                                 ; so now our main loop runs on the outside with LED 1 and 4, and then
                                 ; when the button is switched, the sequence adds LEDs 2 and 3 to it with
                                 ; every loop!
;         BCLR  PORTB,%10000000
          
         BRA     mainLoop

********************************************************
* Subroutine Section: address used [ $3100 to $3FFF ] RAM memory
********************************************************
********************************************************
* delay1sec subroutine
********************************************************
; This subroutine introduces a delay of approximately 1 second.
; It utilizes the Y register as a counter and calls delayMS
; repeatedly to accumulate the desired time delay.
; 
; Input: Counter2 value
; Output: Time delay of approximately 1 second
; Registers in use: Y register
; Memory locations in use: Counter2 -- 16-bit delay value
; Comments: The overall delay duration is determined by Counter2 * delayMS.

delay1sec PSHY                    ; save Y
         LDY     Counter2         ; long delay by loading Y register with predefined delay count of counter2
                                  ; which was 00E0 %(0000 0000 1110 0000)
dly1Loop JSR     delayMS          ; total time delay = Y * delayMS **call delayMS subroutine to introduce delay**, Y times as much delay as delayMS so multiples of seconds!
         DEY                      ; decrement Y (outer loop counter)
         BNE     dly1Loop         ; reloop if Y is not zero
         PULY                    ; restore original Y value
         RTS                     ; return

********************************************************
* delayMS subroutine
********************************************************
; This subroutine causes few msec. delay
; Input: a 16-bit count number in 'Counter1'
; Output: time delay, CPU cycle wasted
; Registers in use: X register, as counter
; Memory locations in use: 16-bit input number at 'Counter1'
; Comments: one can add more NOP instructions to lengthen
;           the delay time.

delayMS  PSHX                    ; save X to avoid overwriting its value
         LDX     Counter1        ; short delay by loading X register with delay Counter1 valu, X = #0100 or %0000 0001 0000 0000e
dlyMSLoop NOP                    ; total time delay = X * NOP, so X times the number of NOPs, incurring X multiple of msec delay
         DEX                     ; decrement X (inner loop counter)
         BNE     dlyMSLoop       ; repeat loop if X is not zero
         PULX                    ; restore original X
         RTS                     ; return

* Add any subroutines here

         end                     ; last line of a file

